<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ADGroupScopeToStringTransformDescription" xml:space="preserve">
    <value>This transform converts the AD groupType attribute to the string description of the group scope. This transform will return either "Global", "DomainLocal", or "Universal", depending on the presence of flags within the groupType attribute value</value>
  </data>
  <data name="ADGroupTypeToStringTransformDescription" xml:space="preserve">
    <value>This transform converts the AD groupType attribute to the string description of the group type. This transform will return either "Security" or "Distribution", depending on the presence of flags within the groupType attribute value</value>
  </data>
  <data name="BitmaskToBooleanTransformDescription" xml:space="preserve">
    <value>This transform tests for the presence of a flag within a bitmask and returns either "True" if the flag is set, or "False" if it is not</value>
  </data>
  <data name="BitmaskTransformDescription" xml:space="preserve">
    <value>This transform takes an incoming value and applies a flag based on the specified operator.

Bitwise operator description:
And - Tests the presence of the specified flag. If the flag is not set in the incoming value, the transform will always return zero. If the flag is set, the transform will return the flag value.

Or - Sets the flag in the incoming value. If the flag is not set in the incoming value, the transform will set it. If it is already set, the transform makes no changes.

Nand - Unsets the flag in the incoming value. If the flag is set in the incoming value, the transform will unset it. If it is not set, no changes are made to the incoming value.

Xor - Toggles the flag. If the flag is currently set in the incoming value, it will be unset. If it is not set, it will be set.</value>
  </data>
  <data name="BooleanToBitmaskTransformDescription" xml:space="preserve">
    <value>This transform takes an incoming boolean value (true or false) and adds or removes the specified flag value from a bitmask. 

This is a special type of transform known as a 'loop-back' transform that reads in the target value of the transform in order to apply the appropriate value. If the target value is currently not present, then the default value is used.

This transform is commonly used to set the 'account disabled' flag in the AD userAccountControl attribute. You can specify a boolean input value (account disabled = true), and the transform will modify the userAccountControl attribute and add or remove the flag as appropriate.</value>
  </data>
  <data name="ConcatStringTransformDescription" xml:space="preserve">
    <value>This transform joins multiple attribute values together, seperated by the specified delimiting text.</value>
  </data>
  <data name="DateConverterTransformDescription" xml:space="preserve">
    <value>This transform allows for conversion of dates between different formats, and optionally add or subtract time from the incoming date. The transform supports dates in .NET ticks, the FIM Service date format, or any custom date format supported by .NET date format strings</value>
  </data>
  <data name="DelimitedTextFileLookupTransformDescription" xml:space="preserve">
    <value>This transform allows for the lookup of values in a delimted text file. The transform supports CSV and TSV files out of the box, but you can alternatively supply the transform with a custom delimiter to use to find the correct value. 

Lookup transforms are used to find the incoming value in a table, and replace it with another value.

If the incoming value is not found in the lookup table, you can specify what you want the transform to return instead. You can choose between returning nothing, returning the original value, or a fixed default value

The transform supports looking up string, integer, and binary values. Binary values need to be represented in the text file in base-64 encoded format. </value>
  </data>
  <data name="FormatNumberTransformDescription" xml:space="preserve">
    <value>This transform allows you to convert a number to a string in a predetermined format. Any .NET numeric format string is supported.</value>
  </data>
  <data name="FormatStringTransformDescription" xml:space="preserve">
    <value>This transform allows you to insert attribute values into a string of text. Enclose a number inside braces (eg {0}, {1}) within the string to indicate where you want the values inserted. Attribute values are substituted in the order they appear to the transform.</value>
  </data>
  <data name="GetDNComponentTransformDescription" xml:space="preserve">
    <value>This transform allows you to extract a numbered component of a distinguished name. You can choose to return just the full RDN (the attribute/value pair in the format of "CN=value") or just the value.</value>
  </data>
  <data name="GroupStringToADGroupTypeTransformDescription" xml:space="preserve">
    <value>This transform allows you to pass in the text "Security" or "Distribution" and "Global", "Universal", or "DomainLocal", and create an integer value suitable for passing directly to the AD groupType attribute</value>
  </data>
  <data name="HashTransformDescription" xml:space="preserve">
    <value>This transforms hashes a string, binary, or integer value</value>
  </data>
  <data name="MultivalueToSingleValueTransformDescription" xml:space="preserve">
    <value>This transforms allows you to extract a single value from a multivalued attribute based on the criteria you specify</value>
  </data>
  <data name="MVBooleanToBitmaskTransformDescription" xml:space="preserve">
    <value>This transform takes a chain of incoming boolean values and adds or removes the specific flag values from a bitmask.

This is a special type of transform known as a 'loop-back' transform that reads in the target value of the transform in order to apply the appropriate value. If the target value is currently not present, then the default value is used.

This transform can be used to set multiple values in the AD userAccountControl attribute, by passing in several boolean values. You can specify multiple input values and what flags they represent in the bitmask. The transform will use the incoming boolean values to trigger the flags specified in the transform. The number of incoming values must match the number of flags in the transform exactly.</value>
  </data>
  <data name="RegexReplaceTransformDescription" xml:space="preserve">
    <value>This transform allows you to apply a regular expression find-and-replace operation to an incoming string value</value>
  </data>
  <data name="RemoveDiacriticsTransformDescription" xml:space="preserve">
    <value>This transform removes diacritical marks (accents, etc) from a string, returning the base character in its place</value>
  </data>
  <data name="SidStringBiDirectionalTransformDesciption" xml:space="preserve">
    <value>This transform allows you to either
1. Pass in a binary SID value, and receive a string-based SID
2. Pass in a string-based SID, and receive a binary SID

The transform automatically detects the type of incoming data (either a binary or string value) and applies the appropriate transformation to it</value>
  </data>
  <data name="SidToDomainTransformDescription" xml:space="preserve">
    <value>This transform takes a user SID, and extracts the Active Directory domain from it. You can choose to return the domain information either as 

1. A binary SID value
2. A string SID value
3. The netBIOS name of the domain

The transform can only return the netBIOS name of the domain, if that domain is known to the server where the transform is executing. If the domain cannot be resolved into a name, the string representation of the SID is returned</value>
  </data>
  <data name="SimpleLookupTransformDescription" xml:space="preserve">
    <value>This transform allows for the lookup of values in a simple two-column table, stored within the transform configuration itself. This type of lookup is idea for small lookup tables.

Lookup transforms are used to find the incoming value in a table, and replace it with another value.

If the incoming value is not found in the lookup table, you can specify what you want the transform to return instead. You can choose between returning nothing, returning the original value, or a fixed default value

The transform supports looking up string, integer, and binary values. Binary values need to be represented in base-64 encoded format.</value>
  </data>
  <data name="StringCaseTransformDescription" xml:space="preserve">
    <value>This transform allows converting a string to either upper, lower, or title case</value>
  </data>
  <data name="SubstringTransformDescription" xml:space="preserve">
    <value>This transform allows extracting only certain characters from an incoming string value. The transform can perform extractions from either the left or the right hand side of the string, and supports padding the resulting string to meet a specified minimum character length</value>
  </data>
  <data name="TrimStringTransformDescription" xml:space="preserve">
    <value>This transform removes leading and/or trailing spaces from a string</value>
  </data>
  <data name="TypeConverterTransformDescription" xml:space="preserve">
    <value>This transforms allows you to convert a value to a specified data type, provided the type conversion is valid.</value>
  </data>
  <data name="XmlLookupTransformDescription" xml:space="preserve">
    <value>This transform allows for the lookup of values in an XML file using an XPath expression.

Lookup transforms are used to find the incoming value in a table, and replace it with another value.

If the incoming value is not found in the lookup table, you can specify what you want the transform to return instead. You can choose between returning nothing, returning the original value, or a fixed default value

The transform supports looking up string, integer, and binary values. Binary values need to be represented in base-64 encoded format.</value>
  </data>
  <data name="BooleanOperationTransformDescription" xml:space="preserve">
    <value>The transform performs a logical operation on multiple boolean values</value>
  </data>
  <data name="StringSplitTransformDescription" xml:space="preserve">
    <value>This transforms splits a single-valued string using a regular expression into a multivalued string</value>
  </data>
  <data name="NumberCalculationTransformDescription" xml:space="preserve">
    <value>This transforms allows you to perform a mathematical operation on a value</value>
  </data>
  <data name="ValueMergeTransformDescription" xml:space="preserve">
    <value>This transform allows you to merge values into a single, compatible type, and removes any duplicate values from the merged list</value>
  </data>
  <data name="StringEscapeTransformDescription" xml:space="preserve">
    <value>The transforms allows you to escape invalid characters from an XML string, or an LDAP DN component's attribute value</value>
  </data>
  <data name="EncodeStringTransformDescription" xml:space="preserve">
    <value>The transform allows you to encode a binary value as a base-32 or base-64 string, or a string value as a ASCII or UTF binary value</value>
  </data>
  <data name="XPathQueryTransformDescription" xml:space="preserve">
    <value>The transform allows for the extration of values from an XML blob using an XPath expression</value>
  </data>
  <data name="ConditionalStringFlowTransform" xml:space="preserve">
    <value>This transform compares the incoming value with the target value, using the specified comparison method. If the values do not match, then the incoming value is used. If the values match, then no change is made to the target value. This can be used to prevent case changes from flowing to a target system</value>
  </data>
  <data name="PowerShellScriptPathTransformDescription" xml:space="preserve">
    <value>The transform allows the use of a custom PowerShell script to transform values</value>
  </data>
  <data name="CSharpScriptTransformDescription" xml:space="preserve">
    <value>This transform allows custom C# code to be loaded to perform transformation of values</value>
  </data>
</root>